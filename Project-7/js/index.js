// Generated by CoffeeScript 1.7.1

/*
Author: Derek Benson
Date: 12/8/2015
Name: Index.coffee
 */


/*
Creates the Blade of a propellor
 */

(function() {
  var Blade, Cloud, Mountain, Plane, Propellor, RotatingPlane,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Blade = (function(_super) {
    __extends(Blade, _super);

    function Blade() {
      Blade.__super__.constructor.call(this);
      this._thickness = 1;
      this._width = 2.5;
      this._length = 25;
      this._blade = new THREE.Mesh(new THREE.BoxGeometry(this._thickness, this._width, this._length), new THREE.MeshLambertMaterial({
        color: 0x8D6E63
      }));
      this._blade.position.set(this._thickness / 2, 0, 0);
      this.add(this._blade);
    }

    return Blade;

  })(THREE.Object3D);


  /*
  Creates a Propellor and defines its spin
   */

  Propellor = (function(_super) {
    __extends(Propellor, _super);

    function Propellor() {
      this.spin = __bind(this.spin, this);
      var blade, i, _i, _len, _ref;
      Propellor.__super__.constructor.call(this);
      this._prop = [new Blade, new Blade];
      this._rotation = Math.PI / this._prop.length;
      _ref = this._prop;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        blade = _ref[i];
        blade.rotation.set(i * this._rotation, 0, 0);
        this.add(blade);
      }
    }

    Propellor.prototype.spin = function(rads) {
      var blade, _i, _len, _ref, _results;
      _ref = this._prop;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        blade = _ref[_i];
        _results.push(blade.rotation.x += rads);
      }
      return _results;
    };

    return Propellor;

  })(THREE.Object3D);


  /*
  Organizes a body, wings, and Propellor into a Plane
   */

  Plane = (function(_super) {
    __extends(Plane, _super);

    function Plane() {
      this.spinProp = __bind(this.spinProp, this);
      var bodyGeometry, bodyMaterial, finGeometry, length, radius, wingGeometry, wingMaterial;
      Plane.__super__.constructor.call(this);
      radius = 7;
      length = 100;
      bodyGeometry = new THREE.CylinderGeometry(radius, radius, length, 200);
      bodyMaterial = new THREE.MeshLambertMaterial({
        color: 0x757575
      });
      this._body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      this._body.rotation.set(0, 0, Math.PI / 2);
      wingGeometry = new THREE.BoxGeometry(20, 3, 75);
      wingMaterial = new THREE.MeshLambertMaterial({
        color: 0x90A4AE
      });
      this._wing = new THREE.Mesh(wingGeometry, wingMaterial);
      finGeometry = new THREE.BoxGeometry(15, 15, 1);
      this._fin = new THREE.Mesh(finGeometry, wingMaterial);
      this._fin.position.set(-length / 2 + Math.pow(15 * 15 + 15 * 15, 0.5) / 2, radius, 0);
      this._fin.rotation.set(0, 0, -Math.PI / 4);
      this._prop = new Propellor;
      this._prop.position.set(length / 2, 0, 0);
      this.add(this._prop);
      this.add(this._body);
      this.add(this._wing);
      this.add(this._fin);
    }

    Plane.prototype.spinProp = function(rads) {
      return this._prop.spin(rads);
    };

    return Plane;

  })(THREE.Object3D);


  /*
  Creates a plane that rotates around a specific point at a certain radius
   */

  RotatingPlane = (function(_super) {
    __extends(RotatingPlane, _super);

    function RotatingPlane(radius, speed) {
      this.speed = speed;
      this.tick = __bind(this.tick, this);
      this.spinProp = __bind(this.spinProp, this);
      RotatingPlane.__super__.constructor.call(this);
      if (!this.speed) {
        this.speed = 0;
      }
      this.plane = new Plane;
      this.plane.position.set(0, 0, radius);
      this.propSpeed = 0.25;
      this.add(this.plane);
    }

    RotatingPlane.prototype.spinProp = function(rads) {
      return this.plane.spinProp(rads);
    };

    RotatingPlane.prototype.tick = function() {
      this.rotation.y += this.speed;
      return this.spinProp(this.propSpeed);
    };

    return RotatingPlane;

  })(THREE.Object3D);

  Cloud = (function(_super) {
    __extends(Cloud, _super);

    function Cloud(count, radius) {
      var callback, getRandom, texture;
      Cloud.__super__.constructor.call(this);
      this._droplets = [];
      getRandom = function() {
        return (2 * radius * Math.random()) - radius;
      };
      callback = (function(_this) {
        return function() {
          var droplet, dropletGeometry, dropletMaterial, i, _i, _results;
          dropletGeometry = new THREE.SphereGeometry(25 * radius / count, 32, 16);
          dropletMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
            transparent: true,
            color: 0xeeeeee
          });
          _results = [];
          for (i = _i = 1; 1 <= count ? _i <= count : _i >= count; i = 1 <= count ? ++_i : --_i) {
            droplet = new THREE.Mesh(dropletGeometry, dropletMaterial);
            droplet.position.set(getRandom(), getRandom(), getRandom());
            _this._droplets.push(droplet);
            _results.push(_this.add(droplet));
          }
          return _results;
        };
      })(this);
      texture = THREE.ImageUtils.loadTexture('images/cloud.png', {}, callback);
    }

    return Cloud;

  })(THREE.Object3D);


  /*
  Creates a Mountain of a specific radius at the bottom and height
   */

  Mountain = (function(_super) {
    __extends(Mountain, _super);

    function Mountain(radius, height) {
      var mountainGeometry, mountainMaterial;
      Mountain.__super__.constructor.call(this);
      mountainGeometry = new THREE.CylinderGeometry(0, radius, height, 40);
      mountainMaterial = new THREE.MeshLambertMaterial({
        color: 0x5D4037
      });
      this._mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
      this.add(this._mountain);
    }

    return Mountain;

  })(THREE.Object3D);

  window.onload = function() {

    /*
    THREE.js Initilization
     */
    var ambientLight, camera, cloud1, cloud2, controls, keyDownListener, light, mountain, plane1, plane2, render, renderer, scene, skyLight;
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
    renderer = new THREE.WebGLRenderer({
      antialiasing: true
    });
    if (Detector.webgl) {
      renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      renderer.setClearColor(new THREE.Color(0xEEEEEE));
    } else {
      renderer = new THREE.CanvasRenderer();
    }
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.set(0, 150, 800);
    camera.lookAt(scene.position);

    /*
    Lighting
     */
    light = new THREE.PointLight(0xffffff);
    light.position.set(500, 250, 0);
    ambientLight = new THREE.AmbientLight(0x111111);
    skyLight = new THREE.HemisphereLight(0xffffff, 0x080808, 1);
    scene.add(light);
    scene.add(skyLight);
    scene.add(ambientLight);

    /*
    Controls
     */
    controls = new THREE.OrbitControls(camera, renderer.domElement);

    /*
    Object Initialization
     */
    plane1 = new RotatingPlane(350, 0.04);
    plane2 = new RotatingPlane(500, 0.025);
    scene.add(plane1);
    scene.add(plane2);
    cloud1 = new Cloud(250, 50);
    cloud1.position.set(350, 0, -125);
    cloud2 = new Cloud(75, 50);
    cloud2.position.set(-150, 0, 50);
    scene.add(cloud1);
    scene.add(cloud2);
    mountain = new Mountain(200, 350);
    scene.add(mountain);

    /*
    Render Loop
     */
    render = function() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
      plane1.tick();
      plane2.tick();
      cloud1.rotation.y += 0.045;
      cloud2.rotation.y += 0.045;
      cloud1.rotation.x += 0.045;
      cloud2.rotation.x += 0.045;
      return controls.update();
    };
    keyDownListener = function(e) {
      var adjustSpeed;
      adjustSpeed = function(ds, plane) {
        return plane.speed += ds;
      };
      switch (e.keyCode) {
        case 87:
          return adjustSpeed(0.005, plane1);
        case 83:
          return adjustSpeed(-0.005, plane1);
        case 69:
          return adjustSpeed(0.005, plane2);
        case 68:
          return adjustSpeed(-0.005, plane2);
      }
    };
    document.addEventListener("keydown", keyDownListener, false);
    return render();
  };

}).call(this);
